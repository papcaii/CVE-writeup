# CVE-2023-28218  
 
## Description  
***Exploiting Windows Kernel Wild Copy With User Fault Handling*** 

## Environment setup

- Vulnerable driver: `afd.sys`
- Target: `Windows 11 Version 21H2 for x64-based Systems`
- Vulnerable build: `10.0.22000.1455`
- Patched build: `10.0.22000.1817`

## Vulnerability
Hàm gây ra lỗi và được vá là hàm `afdCopyCMSGBuffer`. Cụ thể hàm này fetch data từ user memory nhiều lần, kiểm tra các điều kiện và cuối cùng thực hiện hàm memmove để copy data từ user memory sang kernel memory  

-> Có thể dùng race condition để thay đổi size của buffer được copy  
-> Kernel pool overflow  
-> Sử dụng cơ chế named pipe để đạt được arbitrary read/write  
-> Token stealing  
-> LPE

Before:   
![image](https://github.com/papcaii/CVE-writeup/assets/109308566/d29536cc-e1a3-457b-8230-70a764737862)   
After:  
![image](https://github.com/papcaii/CVE-writeup/assets/109308566/75b02a82-63b3-4f80-aeca-b1227a713bb6)

## Reverse

Sử dụng tính năng cross-reference trong IDA, ta thấy rằng có một số hàm này sẽ gọi đến `AfdCopyCMGBuffer`  
![image](https://github.com/papcaii/CVE-writeup/assets/109308566/3b4faf4c-fadc-4c1b-8ee6-a2fcd2ec6321)

Đến đây ta cần tìm cách để tương tác được với afd.sys, ta có một vài lựa chọn như:
- CreateFile API: Nhưng như này sẽ khó để set được chính xác irp mong muốn
- NtCreateFile: Cần phải set đúng các undocumented attributes
- Winsock API: Giống như cách tương tác với `CVE-2023-21768`, đây là cách dễ nhất để tương tác với afd.sys, vậy nên ta sẽ dùng phương pháp này

Tiếp tục dịch ngược, ta tìm được với IOCTL 0x120D3 truyền vào sẽ dẫn tới hàm `AfdSendMessageDispatch` -> `AfdExtractAfdSendMsgInfo` -> `AfdCopyCMSGBuffer`

#### AfdSendMessageDispatch
- Sau khi thử gửi một vài io request đến thì breakpoint tại hàm này được hit nhưng bị fail sau một vài check condition
- ![image](https://github.com/papcaii/CVE-writeup/assets/109308566/e3888f79-aa68-4cbe-a951-f5f3f25be3ab)

- Tìm hiểu kỹ hơn thì đoạn check này sẽ so sánh giá trị trỏ từ rbx với 0xAFD1, nếu bằng thì sẽ fail
- 0xAFD1 biểu thị đây là một datagram socket, vậy nên ta chỉ cần set socket thành stream socket như TCP là pass 

#### AfdExtractCMSGBuffer
- Hàm `IoIs32bitProcees` được gọi, ở đây tôi sẽ chọn flow mà điều kiện này thỏa mãn -> Cần compile exploit ở 32-bit
- `AfdComputeCMSGLength`: Tính lượng byte cần để allocate
- `AfdAllocateMdlChain`: Kiểm tra liệu user-mode buffer có thỏa mãn để kernel access mà không gây ra page faults không
    - user-mode buffer khong được là NULL
    - cần allign theo 4-byte 
    - địa chỉ lớn hơn `MmUserProbeAddress`
- `AfdBuildSendMsgTracker`: Hàm này có nhiệm vụ allocate memory cho
    - Kiểm tra CMSG data không lớn hơn 0x86
    - Allign 8-byte rồi cộng giá trị với 0x50 và gọi hàm `ExAllocatePoolWithQuotaTag`

#### AfdCopyCMGBuffer

```c++
NTSTATUS AfdCopyCMSGBuffer(
    _In_ PVOID SmtxBuffer,
    _In_ PVOID UmPointerWithControlledData,
    _In_ DWORD CopySize
);
```  
Ta đã đến được hàm gây lỗi
- Kiểm tra xem SizeOfUmPointer lớn hơn 0x10
- Ở đây size sẽ trải qua nhiều bước check để rồi cuối cùng sẽ copy số byte theo size đó từ user vào kernel
- Vì liên tục được fetch từ user pointer, nếu sau khi qua một vài bước ta thay đổi size thành 0xfffffff8 thì sẽ gây ra lỗi Integer Overflow dẫn đến ta pass được các bước kiểm tra sau đó
- Từ đây ta có được Pool Overflow

## Exploit

Như đã nói ở trên, khi thay đổi được size trong quá trình hàm chạy ta sẽ có được Pool Overflow, ở đây ta có thể toàn quyền control được data truyền vào, vậy nên ta có thể dùng kỹ thuật với named pipe để đạt được quyền read/write trên toàn memory (Đọc kỹ hơn về kỹ thuật này trong phần [Reference](##Reference))

Quá trình exploit như sau:
- Alloc user address để build các payload thỏa mãn các check trên 
- Spray các named pipe rồi Close một vài pipe để tạo các holes trong pool
- Dùng 2 thread để trigger race condition:
    - Thread1 để gửi các io request đến afd
    - Thread2 để liên tục thay đổi size của CMSG
- Xác định pipe bị corrupted
- Dùng pipe này và cơ chế trong named pipe để đạt quyền arbitrary read/write
- Leak process structure của system process và current process
- Thực thi token stealing để đạt được System Privilege

## Preview
![CVE-2022-28218](https://github.com/papcaii/CVE-writeup/assets/109308566/69817b94-52b6-4a18-a87f-35b2231afd3d)

## What to do
- Kernel sẽ bị crash sau khi đóng cmd vì các named pipe bị collapsed, nên tìm hiểu và cải thiện chỗ này

## Reference
[Offensive](https://offensive.dev/2023/07/from-vulnerability-to-insight-root-cause-analysis-of-cve-2023-28218/)  
[Theori BLOG](https://blog.theori.io/exploiting-windows-kernel-wild-copy-with-user-fault-handling-cve-2023-28218-89f5189d0926)

### Exploit Pool Overflow with named pipe
[HEVD](https://github.com/vportal/HEVD)  
[vp777](https://github.com/vp777/Windows-Non-Paged-Pool-Overflow-Exploitation/tree/master)
