# CVE-2023-28218  
 
## Description  
***Exploiting Windows Kernel Wild Copy With User Fault Handling*** 

## Environment setup

- Vulnerable driver: `afd.sys`
- Target: `Windows 11 Version 21H2 for x64-based Systems`
- Vulnerable build: `10.0.22000.1455`
- Patched build: `10.0.22000.1817`

## Vulnerability
#### Loại lỗi
- Biến `UserCopyAddr` (user-mode memory) được fetch để kiểm tra size ở hàm `AfdComputeCMSGLength`  
  ![Fetch lần 1](https://github.com/papcaii/CVE-writeup/assets/109308566/a614f0e0-b810-45d1-a375-c7bf8633db84)

- Sau đó sẽ được fetch lần nữa ở hàm `AfdCopyCMSGBuffer` để copy data từ user-mode vào kernel-mode
![Fetch lần 2](https://github.com/papcaii/CVE-writeup/assets/109308566/c7be012f-56c8-446c-8876-480f13adedd6)

- Lỗi xảy ra khi `UserCopyAddr` bị thay đổi giữa hai lần fetch dẫn đến việc số byte được copy vào kernel nhiều hơn vùng được alloc (size vùng này được tính từ hàm `AfdComputeCMSGLength`)
-> Double fetch

- Khi đã qua các check ở các hàm trước và thay đổi UserCopyAddr->Length thành giá trị trong khoảng [0xfffffff5, 0xfffffffb] (để thỏa mãn các check về int overflow) 
- Ta sẽ được quyền overflow [0xffffffe9, 0xffffffef] bytes vào kernel memory

![image](https://github.com/papcaii/CVE-writeup/assets/109308566/7ad7a85a-7a7c-4d14-afc6-763454709461)

-> Pool Overflow

#### Cách tương tác  
Sử dụng tính năng cross-reference trong IDA, ta thấy rằng có một số hàm này sẽ gọi đến `AfdCopyCMGBuffer`  
![image](https://github.com/papcaii/CVE-writeup/assets/109308566/3b4faf4c-fadc-4c1b-8ee6-a2fcd2ec6321)

Đến đây ta cần tìm cách để tương tác được với afd.sys, ta có một vài lựa chọn như:
- CreateFile API: Nhưng như này sẽ khó để set được chính xác irp mong muốn
- NtCreateFile: Cần phải set đúng các undocumented attributes
- Winsock API: Giống như cách tương tác với `CVE-2023-21768`, đây là cách dễ nhất để tương tác với afd.sys, vậy nên ta sẽ dùng phương pháp này

## Reverse  

Tiếp tục dịch ngược, ta tìm được với IOCTL 0x120D3 truyền vào sẽ dẫn tới hàm `AfdSendMessageDispatch`, và vì đây là một fastcall nên trước đó nó sẽ đến hàm `AfdFastIoDeviceControl` trước.

Khi thử send một vài IO request đến thì AfdCopyCMSG luôn thành công được gọi từ hàm `AfdFastIoDeviceControl`, còn khi đi tiếp theo flow của hàm `AfdSendMessageDispatch` sẽ bị catch fault giữa chừng, vậy nên ta sẽ chọn theo flow đầu 

Flow sẽ là:
- `AfdFastIODeviceControl`: Được gọi khi gọi `DeviceIoControl` với IOCTL 0x120D3
- `AfdComputeCMSGLength`: Tính size cần để allocate kernel memory, đồng thời kiểm tra integer overflow
- `ExAllocatePool2`: Alloc kernel memory theo size tính được từ hàm Compute
- `AfdCopyCMSGBuffer`: Copy data từ user memory vào kernel pool vừa được alloc

  ![image](https://github.com/papcaii/CVE-writeup/assets/109308566/1b382479-0a18-44d5-9b47-49de7145b402)


#### AfdCopyCMGBuffer

```c++
NTSTATUS AfdCopyCMSGBuffer(
    _In_ PVOID SmtxBuffer,
    _In_ PVOID UmPointerWithControlledData,
    _In_ DWORD SizeOfUmPointer
);
```  
Ta đã đến được hàm gây lỗi, parameter thứ hai của hàm có dạng như này

```c++
typedef struct _SECONDARY_MESSAGE_BUFFER
{
    DWORD Length;
    PDWORD Buffer;
}
```

Đi vào hàm, ta thấy flow như sau:
- Kiểm tra xem SizeOfUmPointer lớn hơn 0x10
- Ở đây Length sẽ trải qua nhiều bước check để rồi cuối cùng sẽ copy số byte theo Length đó từ user vào kernel
- Vì liên tục được fetch từ user pointer, nếu sau khi qua một vài bước ta thay đổi size thành khoảng size như nói ban đầu thì sẽ gây ra lỗi Integer Overflow dẫn đến ta pass được các bước kiểm tra sau đó
- Từ đây ta có được Pool Overflow

## Exploit
#### Tiềm năng lỗi
- Dựa vào lỗi này ta sẽ có được quyền overflow lên đến 0xffffffef bytes ở vùng NonPagedPoolNX ở đây ta có thể toàn quyền control được data truyền vào, nhưng vì vậy chúng ta có một vấn đề là lượng overflow quá lớn sẽ dẫn đến ta không thể kiểm soát được tất cả data overflow
- Nhưng nếu để ý code, ta có thế thấy có case try-except ở đây, vì vậy ta có thể lợi dụng điều này
 - source address của hàm `AfdCopyCMSGBuffer` là user memory mà ta có thể tùy ý control
 - khi copy đến unmapped memory thì case except sẽ được thực thi
- Vì vậy ta sẽ dùng `VirtualAlloc` alloc như sau:
 - `userBuf` là trỏ đến memory sẽ được copy
 - `copyBytes` là số bytes ta muốn copy  
```c++
VirtualAlloc((PVOID)0x1000000, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
BYTE *userBuf = (BYTE *)0x1000000 + 0x1000 - copyBytes;
```

 ![image](https://github.com/papcaii/CVE-writeup/assets/109308566/a15e4d22-8044-45cf-ba2a-e4438921a004)

- vậy nên ta có thể dùng kỹ thuật với named pipe để đạt được quyền read/write trên toàn memory (Đọc kỹ hơn về kỹ thuật này trong phần [Reference](##Reference))

Quá trình exploit như sau:
- Alloc user address để build các payload thỏa mãn các check trên 
- Spray các named pipe rồi Close một vài pipe để tạo các holes trong pool
- Dùng 2 thread để trigger race condition:
    - Thread1 để gửi các io request đến afd
    - Thread2 để liên tục thay đổi size của CMSG
- Xác định pipe bị corrupted
- Dùng pipe này và cơ chế trong named pipe để đạt quyền arbitrary read/write
- Leak process structure của system process và current process
- Thực thi token stealing để đạt được System Privilege

## Preview
![CVE-2022-28218](https://github.com/papcaii/CVE-writeup/assets/109308566/69817b94-52b6-4a18-a87f-35b2231afd3d)

## What to do
- Kernel sẽ bị crash sau khi đóng cmd vì các named pipe bị collapsed, nên tìm hiểu và cải thiện chỗ này

## Reference
[Offensive](https://offensive.dev/2023/07/from-vulnerability-to-insight-root-cause-analysis-of-cve-2023-28218/)  
[Theori BLOG](https://blog.theori.io/exploiting-windows-kernel-wild-copy-with-user-fault-handling-cve-2023-28218-89f5189d0926)

### Exploit Pool Overflow with named pipe
[HEVD](https://github.com/vportal/HEVD)  
[vp777](https://github.com/vp777/Windows-Non-Paged-Pool-Overflow-Exploitation/tree/master)
