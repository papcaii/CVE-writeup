<img width="688" alt="image" src="https://github.com/papcaii/CVE-writeup/assets/109308566/bbc5c896-5d4e-45e8-bebc-09de7d051f3d"><img width="232" alt="image" src="https://github.com/papcaii/CVE-writeup/assets/109308566/075dc8e3-3f31-4466-a798-8a8dfbc12a6d"># CVE-2023-21768
          
CVE-2023-21768 target đến afd.sys - một driver handle các network operations, như socket...

## Reverse

Trước hết ta sẽ dùng một kĩ thuật là binary diff giữa bản patched và bản chưa patched để xác định và giới hạn các hàm được fix
<img src="https://i.imgur.com/QMgSJJf.png">

Rất may là chỉ có 1 hàm được thay đổi, đó chính là hàm `afd!AfdNotifyRemoveIoCompletion`
<img src="https://i.imgur.com/YxhV4ZW.png">

Như đã thấy thì ở bản patched hàm ProbeForWrite đã được thêm vào ở case khi `PreviousMode != 0` (Nếu `PreviousMode = 0` nghĩa là chương trình đang chạy ở Kernel mode, ngược lại thì đang ở User mode)
Hàm này sẽ kiểm tra xem liệu address đưa vào có phải địa chỉ hợp lệ nằm trong User mode không

--> Từ đó ta có thể suy ra rằng nếu ta có thể pass một address nằm ở Kernel mode ta có thể có được quyền write trên toàn memory

Tuy nhiên, để khai thác được lỗ hổng này thì ta phải tìm hiểu xem làm thế nào để kích hoạt được đoạn code lỗi ở trên. Ta thấy `AfdNotifyRemoveIoCompletion` chỉ được gọi duy nhất bởi hàm `AfdNotifySock`.
<img src="https://i.imgur.com/4mnUtFX.png">

Tuy nhiên, `AfdNotifySock` lại không được gọi trực tiếp bởi hàm nào. Địa chỉ của
hàm này nằm trong một bảng địa chỉ hàm có tên là `AfdImmediateCallDispatch`.
Các hàm này được ánh xạ từ bảng `AfdIrpCallDispatch`, chứa các dispatch routine cho
AFD driver. Dispatch routine được sử dụng để xử lý các request từ ứng dụng win32
khi gọi `DeviceIoControl`. Control code của mỗi hàm được ghi trong `AfdIoctlTable`.
<img src="https://i.imgur.com/hRwUwVh.png">

Mỗi control code có kích thước 4 byte. Offset của `AfdNotifySock` trong bảng
`AfdImmediateCallDispatch` là 74. Áp vào bảng `AfdIoctlTable`, ta thấy control code
của `AfdNotifySock` là 0x12127.

`AfdNotifySock` có thể gọi thông qua DeviceIoControl, nhưng nếu dựa vào [Code](https://www.x86matthew.com/view_post?id=ntsockets) của x86matthew ta có thể bỏ qua WinSock mà gọi thẳng đến AFD driver thông qua `NtCreateFile` và `NtDeviceIoControlFile`.
<img src="https://i.imgur.com/g6LEhri.png">

Sau khi tạo socket, ta có thể giao tiếp với AFD driver thông qua việc sử dụng
`NtDeviceIoControlFile`. Giá trị `IoControlCode` được truyền vào hàm sẽ đại diện
cho hành động mà ta muốn thực hiện (kết nối, gửi, nhận,...).
<img src="https://i.imgur.com/Ej88KdZ.png">

Quay trở lại với lỗi trong hàm `AfdNotifyRemoveIoCompletion`, nếu ta có thể
đặt giá trị trong structure thành một địa chỉ theo ý muốn thì ta sẽ khai thác được
lỗi này. Structure đó chính là biến `InputBuffer` của `NtDeviceIoControlFile`. Ta sẽ
đọc hàm `AfdNotifySock` để xem làm thế nào để kích hoạt được đoạn code lỗi trong
`AfdNotifyRemoveIoCompletion`.
Đầu tiên, có đoạn code so sánh kích thước Structure của ta với 0x30 byte,
nếu không bằng thì hàm sẽ trả về lỗi `STATUS_INFO_LENGTH_MISMATCH`
(0xC0000004).
<img width="457" alt="image" src="https://github.com/papcaii/CVE-writeup/assets/109308566/9bf9fc54-89a4-4034-bba0-a38fdbbbeff9">

Sau đó, một loạt trường trong Structure của ta sẽ được kiểm tra giá trị.
<img width="423" alt="image" src="https://github.com/papcaii/CVE-writeup/assets/109308566/3887d685-e6ba-4b95-b155-0ca558ea5ce9">

Tiếp theo, hàm ObReferenceObjectByHandle được gọi với một đầu vào là trường
đầu tiên trong Structure của ta. Giá trị trả về của hàm phải lớn hơn hoặc bằng 0
(STATUS_SUCCESS) để đi được đến AfdNotifyRemoveIoCompletion. Để làm
được như vậy thì trường đầu tiên trong Structure phải là một handle của object
IoCompletionObject. Ta có thể gọi NtCreateIoCompletion để thu được handle này
<img width="688" alt="image" src="https://github.com/papcaii/CVE-writeup/assets/109308566/97c4391f-6aeb-4fba-8e36-fd96fe989da3">

Ở đoạn code tiếp tục xuất hiện một vòng lặp mà biến đếm được lấy từ một trường
trong Structure của ta. Vòng lặp này lấy một giá trị trong Structure, kiểm tra xem
nó có là địa chỉ trong User mode không rồi copy dữ liệu từ đó. Ta có thể sử dụng
VirtualAlloc để thu được địa chỉ hợp lệ và đặt biến counter bằng 1
<img width="388" alt="image" src="https://github.com/papcaii/CVE-writeup/assets/109308566/0061b8e4-e1d1-4e00-b89b-2421e5787ee8">

Từ đây, ta dã vào trong được hàm `AfdNotifyRemoveIoCompletion`. Đầu tiên,
có một đoạn code kiểm tra một trường trong Structure phải khác 0. Trường này
được nhân với 0x20, rồi truyền vào hàm `ProbeForWrite` với một trường khác trong
Structure đóng vai trò địa chỉ. Ta tiếp tục dùng VirtualAlloc cho phần địa chỉ và
đặt trường ban đầu là 1.

Cuối cùng, hàm IoRemoveCompletion được gọi và giá trị trả về của hàm này
phải bằng 0. Để có được giá trị trả về như vậy, một "completion record" I/O phải tồn
tại và chưa hết giá trị "timeout". Giá trị "timeout" lấy từ Structure của ta nên có thể
kiểm soát được. Bên cạnh đó, ta gọi NtSetIoCompletion lên IoCompletionObject
ta tạo ở trên để đảm bảo IoRemoveCompletion sẽ trả về STATUS_SUCCESS.

Sau khi vượt qua toàn bộ các đoạn code check như vậy, ta đã đến phần code bị
lỗi và có thể ghi địa chỉ mà ta muốn ghi đè dữ liệu và Structure để kích hoạt lỗi
OOB Write. Giá trị mà ta ghi được là một giá trị trả về của IoRemoveIoCompletion.
Giá trị này phụ thuộc vào số lần ta gọi đến NtSetIoCompletion ở trên.

## Exploit
Như vậy, ta đã có khả năng ghi một giá trị cố định (trong trường hợp này là
0x1, do ta gọi NtSetIoCompletion một lần) vào một địa chỉ do ta tự chọn. Để có
thể tiếp tục khai thác, ta sẽ quan tâm đên Windows I/O ring object. Theo định
nghĩa của Microsoft, I/O ring quản lý hai hàng đợi: một hàng đợi dành cho các I/O
operation (read, write,...) cần được thực hiện không đồng bộ (Submission Queue)
và một hàng đợi khác chứa các kết quả từ các operation đã hoàn thành (Completion
Queue). Các operation trong Submission Queue sẽ được đưa đi thực thi cùng lúc,
kernel sẽ xử lý các yêu cầu đó rồi trả về các giá trị kết quả thực thi trong Completion
Queue

Khi một I/O ring được khởi tạo, structure _IORING_OBJECT được tạo ra trong
kernel space

## Tham khảo

https://www.easefilter.com/Forums_Files/File_IO.htm
https://www.easefilter.com/kb/understand-io-requests.htm
https://www.easefilter.com/kb/understand-irps.htm
https://www.easefilter.com/kb/irp-vs-fast-io.htm

https://windows-internals.com/one-i-o-ring-to-rule-them-all-a-full-read-write-exploit-primitive-on-windows-11/


